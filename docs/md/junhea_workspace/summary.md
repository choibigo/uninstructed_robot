책을 읽으며 요약에 남기면 좋을만한 내용들을 위주로 남겼습니다.

# 점프 투 파이썬

### 1장
#### 파이썬으로 할 수 있는 일
- 웹 프로그래밍
- 인공지능과 머신러닝
- 수치 연산 프로그래밍(numpy)
- 데이터 분석
- ...

#### 파이썬으로 할 수 없는 일
- 시스템과 밀접한 프로그래밍 영역 -> (매우 빠른 속도를 필요로 하는 반복연산에서는 약하다)
- 모바일 프로그래밍


### 2장
#### 숫자형
- 8진수 : 0o숫자
- 16진수 : 0x숫자

#### 문자열 자료형
- 큰따옴표 안에 있는 문장에 쓰인 작은따옴표는 문자열을 만드는 기호로 인식되지 않는다. (반대의 경우도 마찬가지)
- 다만 둘 다 써야할 경우에는 \역슬레시를 이용하여 \\" 또는 \\'로 사용 가능하다. (c언어에서도 \를 두번 사용하여 출력에서 역슬레쉬를 표현 했었던 걸로 기억한다.)
- 작은따옴표나 큰따옴표를 3번 연속해서 사용하여 문자열을 만드는 기호로 사용하면 줄바꿈도 인식한다.
- 이스케이프 코드 종류는 다음과 같다.

코드 | 설명
-- | --
\n | 문자열 안에서 줄을 바꿀 때 사용
\t | 문자열 사이에 탭 간격을 줄 때 사용
\\\\ | \를 그대로 표현할 때 사용
\\' | 작은따옴표(')를 그대로 표현할 때 사용
\\" | 큰따옴표(")를 그대로 표현할 때 사용
\r | 캐리지 리턴(줄 바꿈 문자, 커서를 현재 줄의 가장 앞으로 이동)
\f | 폼 피드(줄 바꿈 문자, 커서를 현재 줄의 다음 줄로 이동)
\a | 벨 소리(출력할 때 PC 스피커에서 '삑' 소리가 난다)
\b | 백 스페이스
\000 | 널 문자

- 문자열 길이 구하기 : ex) len(stringgg)
- 문자열 인덱싱 : 문자(띄어쓰기 포함) 하나당 번호 하나씩 대입하여 list처럼 호출이 가능하다. ex) stringgg[인덱싱 하려고 하는 수]
- 문자열 인덱싱 ++ : stringgg[- 인덱싱 하려고 하는 수] 라고 하면 맨 뒤에서부터 인덱싱 한다. ex) stringgg[-1] 하면 맨 뒤에 있는 문자이다.
- 문자열 슬라이싱 : 인덱싱에서 [a:b] 라고 하면 a번째 부터 b-1번째까지 한번에 접근한다. 단 [a:] 라고 하면 a번째부터 끝까지, [:b] 라고 하면 처음부터 b-1번째까지 접근한다. [a:-b] 역시 가능하다.

###### 문자열 포매팅
- 문자열 포매팅 (c언어에서 printf("%d", a); 와 비슷하다고 보면 된다.) : ex) "I eat %d apples." % 3 //// 3대신 3이라는 정수를 저장하고있는 a와 같은 변수를 입력해도 된다.
- 문자열 포맷 코드 (문자열 포매팅에서 사용된 코드들이다.)

코드 | 설명
-- | --
%s | 문자열(string)
%c | 문자 1개(character)
%d | 정수(integer)
%f | 부동소수(floating-point)
%o | 8진수
%x | 16진수
%% | Literal %(문자 % 자체)

- 포멧 코드와 숫자 함께 사용하기 -> 전체 길이 10개 and 오른쪽 정렬을 원할 때 : %10s //// 왼쪽 정렬 : %-10s
- 소수점 표현 정렬 -> 전체 길이 상관 없이 and 소수점은 4자리까지만 표현을 원할 때 : %0.4f or %.4f
- 소수점 표현 정렬2 -> 전체 길이 10으로 and 소수점은 4자리까지만 표현을 원할 때 : %10.4f ==> (소수점, 숫자 포함 10개로 정렬되며 오른쪽 정렬이 된다.)

###### format함수를 사용한 포매팅
- 포멧 함수 : '%d'와 같은 코드를 {???에서 인덱스할 번호} 로 바꾸고 문자열 맨 뒤 ' % 3' 와 같이 작성했단 것을 .format(???)으로 바꾸면 된다. ???에는 특정 값을 저장한 변수 또는 변수나 문자열 그 자체를 입력해도 된다.
- 포멧 함수에서의 문자 정렬 ex) "back {0:<10}ground anything".format(???) : ???에 넣은 값을 10칸짜리 공간에 출력하는데 왼쪽 정렬 //// "{0:>10}".format(???) : 이건 오른쪽 정렬 //// "{0:^10}".format(???) : 이건 가운데 정렬
- 위의 포멧함수에서의 문자 정렬에서 정렬이후에 나오는 공백을 특정 문자로 채우려면 <, >, ^ 왼쪽에 넣고자 하는 문자를 입력하면 된다. ex) "{0:=<10}".format(???)
- 포멧 함수에서 2개 이상의 값을 한번에 대입할 때에는 "back {0} ground {1} anything {2} is ok".format(?, ??, ???)와 같이 입력하면 된다. {}에는 ?, ??, ??? 숫자 순서대로 대입된다.
- 포멧 함수에서 {}내부에 인덱스할 번호를 적으라고 했지만 이름으로 적어도 된다. 단, format함수 내부에서 name=value와 같은 형태의 입력값으로 되어 있어야 한다. ex) "{name} background{number}".format(name='abc', number=2)
- {}내부에 인덱스 번호와 이름을 혼용하는 것도 가능하다.
- 포멧 함수에서 소수점 표현하는 방식은 포멧 코드를 이용하는 방식과 비슷하다. ex) "{0:0.4f}".format(FloatNumAnyThing)
- 포멧 함수를 사용할 문장에서 } 또는 { 기호를 사용하고 싶다면 "}} 또는 {{" 와 같이 두번 연속하여 입력하면 된다.

###### 문자열 포매팅
- f문자열 포매팅 (파이썬 3.6 버전부터 사용가능한 기능이다.) ex) f'할말 anything {???}background' //// ???에는 특정 값을 저장한 변수 또는 표현식을 넣어도 된다.
- f문자열 포매팅에서 정렬은 다음과 같다. f'{???:<10}' 위와 비슷하게 ???에는 문자열이나 특정 값을 저장한 변수를 넣어도 된다. 마찬가지로 정렬 이후 공백을 무엇으로 채울지 정할 수 있으며 소수점 표현도 비슷하다.

###### 문자열 관련 함수들(문자열 a에 저장된 값 자체를 바꾸는 것이 아닌 리턴값만 바뀐 것이므로 주의하자)
- 문자 개수 세기 ex) a='anything string' //// a.count('g') //// >>> 2
- 문자 위치 찾기 ex) a='anything string' //// a.find('g') //// >>> 7   (문자열에서 g가 처음 나온 위치, 만약 존재하지 않으면 -1을 출력한다.)
- 문자 위치 찾기2 ex) a='anything string' //// a.find('g') //// >>> 7  (문자열에서 g가 처음 나온 위치, 만약 존재하지 않으면 오류가 난다.)
- 문자열 삽입 ex) ",".join('Anything String') //// >>> 'A,n,y,t,h,i,n,g, ,S,t,r,i,n,g'  (문자열 사이에 ,를 삽입했다. join함수 입력으로 리스트나 튜플도 가능하다.)
- 소문자를 대문자로 바꾸기 ex) a.upper()    (a에 저장된 값이 이미 대문자라면 변화가 없다.)
- 대문자를 소문자로 바꾸기 ex) a.lower()    (a에 저장된 값이 이미 소문자라면 변화가 없다.)
- 왼쪽 공백 지우기 ex) a.lstrip()   (a에 저장된 문자열에서 위에서 가운데 정렬이나 오른쪽 정렬 등의 상황에 의해 왼쪽에 공백이 있을 경우 그 공백들을 모두 지운다.)
- 오른쪽 공백 지우기 ex) a.rstrip()    (위와 같다. 단, 오른쪽에 있는 공백을 지운다.)
- 양쪽 공백 지우기 ex) a.strip()    (위와 같다. 단, 양쪽에 있는 공백을 지운다. 하지만 띄어쓰기와 같은 다른 문자들 사이에 있는 공백은 지우지 않는다.)
- 문자열 바꾸기 ex) a='Everything String' //// a.replace('Every', 'Any') //// >>> Anything String     (함수 안에 바뀔 문자열, 바꿀 문자열 순서대로 넣으면 값을 바꿔준다.)
- 문자열 나누기 ex) a='everything string' //// a.split() //// >>> ['everything', 'string']     (괄호 안에 넣은 것이 없으면 공백을 기준으로 문자를 나눈다.)
- 문자열 나누기2 ex) a='te,st:t,e!s:t' //// a.split(':') //// >>> ['te,st', 't,e!s', 't']         (괄호 안에 넣은 문자를 기준으로 나눈다.)

#### 리스트 자료형
###### 리스트 인덱싱
- 문자열과 비슷하다. a[???] 에서 ???에 인덱스 값을 넣어주면 a리스트에서 인덱스에 해당하는 값을 반환한다. -역시 사용이 가능하다.
- 다차원 리스트 : 리스트 안에 리스트를 넣을 수 있다. 이 때 원하는 값에 접근하기 위해서는 3차원일때 예시를 들자면 a[???][??][?] 와 같이 접근한다. -역시 사용이 가능하다.
- 리스트 역시 문자열처럼 슬라이싱 [:]이 가능하다. 이 때 다차원에서 슬라이싱을 한다면 무조건 맨 오른쪽에 적어야 한다. a[???][??][?] 와 같이 있다면 ? 자리에서 슬라이싱을 사용하는 것이 가능하다는 뜻이다.

###### 리스트 연산
- 리스트 더하기 : a = [1, 2, 3] //// b = [1, 2, 3] //// a + b //// >>> [1, 2, 3, 1, 2, 3]
- 리스트 반복하기 : a = [1, 2, 3] //// a * 2 //// >>> [1, 2, 3, 1, 2, 3]
- 리스트 길이 구하기 : a = [1, 2, 3] //// len(a) //// >>> 3
- 리스트 요소 삭제하기 : del a[?]       (?에는 삭제할 요소의 인덱스 값을 넣는다. 이때 삭제된 요소 뒤의 값들의 인덱스 값이 앞으로 오면서 바뀐다. [:] 역시 사용이 가능하다.)

###### 리스트 관련 함수(알고 있는것은 설명 생략)
- 리스트 요소 추가 : a.append(?)
- 리스트 정렬 : a.sort()
- 리스트 뒤집기 : a.reverse() //// a //// >>> (결과물은 a에 저장된 값이 정렬없이 그대로 역순으로 바뀐다.)
- 인덱스 반환 : a.index(?)      (?에 값을 넣으면 그 값이 있는 인덱스 값을 반환하지만 없다면 오류가 난다. 만약 ? 값이 여러개 있다면 맨 앞에 있는 인덱스 값을 반환한다.)
- 리스트에 요소 삽입 : a.insert(???, ??)        (???에는 ??를 집어 넣을 인덱스 번호 위치를 적는다. ???뒤에 있는 원래 있던 요소들은 뒤로 밀리면서 인덱스 값이 바뀐다.)
- 리스트 요소 제거 : a.remove(??)       (a리스트 안에 있는 ?? 값을 제거한다. 만약 ??가 여러개 있다면 맨 앞에 있는 요소만 제거한다.)
- 리스트 요소 끄집어 내기 : a.pop(??)       (??인덱스 값에 해당하는 값을 출력하고 a리스트에서는 이 값이 제거된 상태로 바뀐다. 단, ??에 아무 값도 넣지 않을경우 맨 뒤의 요소가 출력되며 리스트에서 삭제된다.)
- 리스트에 포함된 특정 요소의 개수 세기 : a.count(??)       (??값이 리스트에서 몇개 있는지 출력한다. 문자열에서 .count(??) 와 비슷하다.)
- 리스트 확장 : a.extend(???)       (???에는 []와 같은 리스트 그 자체나 리스트가 저장된 임의의 변수를 넣어도 된다. 출력값은 차원이 늘어나는것이 아닌 길이가 길어진다.)

#### 튜플 자료형
###### 튜플 생성 방식
- 리스트는 []를 사용하지만 튜플은 ()를 사용한다. 리스트와 매우 비슷하지만 튜플은 요솟값의 수정이 불가능하다.
- 튜플은 요소가 하나일 경우에도 (?,)와 같이 ,를 넣어줘야 한다.
- 가장 바깥에 있는 ()는 생략해도 된다. 또한 튜플도 다차원으로 생성이 가능하다. (함수에서 return 할 때 2개 이상의 값을 리턴하는 것과 비슷하다.)

###### 튜플 다루기
- 인덱싱 : a[?] 와 같이 리스트처럼 접근이 가능하다.
- 슬라이싱 : a[:] 와 같이 리스트처럼 가능하다.
- 튜플 더하기와 곱하기 : 요솟값 수정이 불가능하므로 c = a + b 처럼 새로운 튜플이 생성되는 방식으로 가능하다. 덧셈이나 곱셈은 리스트와 같은 방식으로 연산된다.
- 튜플 길이 구하기 : len(a) 와 같이 리스트처럼 가능하다.

#### 딕셔너리 자료형
###### 딕셔너리 생성하기
- 딕셔너리 역시 리스트와 비슷하지만 인덱스 값이 다르다. 그리고 인덱스 값(이하 key) 으로 할 수 있는 것은 변수와 같이 값이 변할 수 있는 것으로 지정할 수 없다.
- a = {???: !, ??: !!, ?: !!!, ... }와 같은 형태로 생성이 가능하며 ???, ??, ? 는 key이고 !, !!, !!!는 value이다.
- key에는 수 그 자체나 문자열, 튜플과 같이 값이 변하지 않는 것이 사용이 가능하다.
- 딕셔너리에 새로운 쌍을 추가하는 방법은 원하는 key 값을 인덱스 칸에 넣고 원하는 값을 반대쪽에 적으면 된다. ex) a['Wantindexxx'] = 'Wantvalueanything'  (딕셔너리 a에 {'Wantindexxx': 'Wantvalueanything'}쌍이 추가된다.)
- 딕셔너리에서 요소 삭제는 삭제할 key값을 넣어서 다음 식을 작성하면 된다. del a['wantdelkey']

###### 딕셔너리 만들 때 주의할 사항
- 딕셔너리에서 key값이 중복되게 사용하면 하나를 제외한 나머지 것들은 전부 무시된다.
- 또한 앞에서 설명했듯이 key값에는 리스트와 같이 변할 수 있는 값을 사용할 수 없다.

###### 딕셔너리 관련 함수
- 딕셔너리에서 key값만 모아서 객체로 리턴하는 함수 : a.keys() //// >>> dict_keys(['???', '??', '?']) //// 여기에서 출력값은 리스트와 비슷하지만 리스트처럼 함수를 사용하는것은 불가능하다.
- value값만 모아서 객체로 리턴하는 함수 : a.values() //// 위와 동일하다.
- key, value 쌍을 객체로 리턴하는 함수 : a.items() //// >>> dict_items([('???', '!'), ('??', '!!'), ('?', '!!!')]) //// items 함수는 key와 value 의 쌍을 튜플로 묶은 값을 객체로 리턴한다.
- key: value 쌍 모두 지우기 : a.clear()
- key로 value 얻기 : a.get(???, ??) //// 여기에서 딕셔너리a 안에 ???를 key로 갖는 쌍이 있다면 그 쌍에서 value를 리턴하지만 없다면 ??를 리턴한다. a[???]와 차이점은 오류를 출력하지 않는다는 것이다. 만약 ??를 입력하지 않으면 get함수에서의 출력은 None이 나온다.
- 원하는 값이 key로 존재하는지 확인하기 : ??? in a //// >>> True //// @@@ in a //// >>> False

#### 집합 자료형
###### 집합 자료형의 생성
- a = set([?, ??, ???]) 또는 a = set('stringanything') 과 같이 입력한다.
- 위의 값을 print(a) 하면 다음과 같이 출력된다. {?, ??, ???} 또는 {'s', 't', 'r', 'i', 'n', 'g', 'a', 'y', 'h'}
- 집합 자료형은 순서가 없으며 중복을 허용하지 않는다.

###### 교집합, 합집합, 차집합 구하기
- 교집합 : s1 & s2 //// s1.intersection(s2) //// 둘중 원하는 것을 사용하면 된다.
- 합집합 : s1 | s2 //// s1.union(s2) //// 둘중 원하는 것을 사용하면 된다.
- 차집합 : s1 - s2 //// s1.difference(s2) //// 둘중 원하는 것을 사용하면 된다.

###### 집합 자료형 관련 함수
- 값 1개 추가하기 : a.add(???)
- 값 여러개 추가하기 : a.update([???, ??, ?])
- 특정 값 제거하기 : a.remove(???)

#### 불 자료형
###### 불 자료형의 생성
- a = True //// a = False (이와 같은 형태로 생성한다. 대소문자 구별한다.)
- 다른 자료형에서도 참 거짓을 알 수 있는데 비어있거나(NULL) 0이면 거짓 아니라면 참이다.

#### 자료형의 값을 저장하는 공간, 변수
###### 변수의 주소
- 변수의 주소는 변수에 저장된 값이 실제 메모리에서 저장된 장소이다. ex) id(a) >>> 4303029896
- 리스트형이 저장된 변수 a를 이용하여 b = a 와 같이 하면 id(b) = id(a) 가 된다. 그리고 a의 안에 저장된 리스트의 내용을 수정하면 b 역시 수정된다. 가리키는 장소(포인터와 같음) 가 동일하기 때문이다.
- 만약 포인터처럼 a가 변하면 b도 똑같이 변하는것을 원하지 않는다면 b = a[:] 와 같이 저장하면 된다.
- 리스트가 아니더라도 from copy import copy 를 하여서 copy(a) 와 같이 함수를 이용해도 된다.

###### 변수를 만드는 여러 방법
- a, b = ('???', '??')
- [a, b] = ['???', '??']
- a 내부의 값과 b 내부의 값을 바꾸는 방법은 a, b = b, a 로 해도 된다.


### 3장
#### if문
- 생략 (요약에 남길만한 새롭게 알게된 내용은 없었습니다.)

#### while문
###### while 문의 맨 처음으로 돌아가기
- while문에서 탈출할때 break를 쓰듯이 continue를 사용하면 while문의 맨 처음 문장으로 되돌아간다.

#### for문
###### for 문의 맨 처음으로 돌아가기
- for문에서도 역시 while에서와 마찬가지로 continue를 사용하는것이 가능하다.
- for문은 다음과 같이 작성해도 된다. [표현식 for 항목 in 반복 가능한 객체 if 조건문]
- 위의 방법에서 for문을 2개 이상 사용하는 것도 가능하다. [표현식 for 항목1 in 반복 가능한 객체1 if 조건문1 for 항목2 in 반복 가능한 객체2 if 조건문2 ...]


### 4장
#### 함수의 정의
###### 매개변수를 지정하여 호출하기
- 보통 def function(a, b): 와 같이 함수를 정의하여 사용하면 function(3, 4) 와 같이 입력값을 바로 넣었지만 function(b=4, a=3)과 같이 작성하면 입력값의 순서를 바꾸어 적어도 결과는 같아진다.

###### 입력값이 몇 개가 될지 모르는 함수 만들기
- def function(*a) 와 같이 *을 앞에 붙이면 입력값을 전부 모아 a 안에 (a 말고 다른거 써도 변수이름으로 사용가능하면 상관x) 입력값을 모두 모아서 튜플로 만들어 준다.
- def function(a, *b) 처럼 다른 변수를 더 받아도 된다. (하지만 *을 사용하는 변수는 맨 뒤에 넣어야 한다. {아닌거같은데..}, *을 사용하는 변수는 하나밖에 사용하지 못한다. {이건 맞는거 같기도 하고...} <---- 맞는지 확인하기)

###### 키워드 매개변수
- 함수의 입력값으로 사용될 변수 앞에 ** 을 붙이면 그 변수값은 딕셔너리 형태가 된다. ex) def function(**a) //// function(i=3, ssf='sfd') //// 함수 지역변수 a에 저장된 값 : {i:3, 'ssf':'sfd'}

###### 함수가 리턴 가능한 갯수
- 함수가 리턴 가능한 갯수는 1개이다. 여러개를 한번에 리턴하면 튜플값으로 리턴하며 리턴을 여러번 하면 위에 있는 리턴값만 내보낸다.

###### 매개변수에 초깃값 미리 설정하기
- ex) def func(a, b, c=True)
- 위와 같이 작성한 뒤에 func('anything', 223) 과 같이 호출해도 되고, func('anything', 223, True) 와 같이 호출해도 입력값은 같아진다.
- func('anything', 223, False) 와 같이 호출해도 된다. 이 경우에는 c값이 처음에 설정한 초깃값과 달라지게 된다.
- 처음 함수를 정의할때 초깃값을 설정하면서 def func(a, c=True, b)와 같이 정의하면 오류가 난다. 초깃값 설정을 하려고 하는 매개변수는 무조건 맨 뒤에 위치해야한다.

###### 지역변수와 전역변수
- 전역변수로 설정한 변수a를 함수내부에서 사용하려면 함수 내부에서 global a 와 같이 입력해야 한다.

###### 함수를 정의하는 다른 방법
- lambda 를 사용할 수 있다. ex) 함수이름 = lambda 매개변수1, 매개변수2, 매개변수3, ... : 매개변수를 이용한 식
- ex) add = lambda a, b: a + b ==== def add(a, b): return a + b

#### 사용자 입출력
###### 사용자 입력 받기
- input() 을 이용한다. 이 함수를 이용하여 사용자로부터 받은 모든 것은 문자열로 저장된다. ex) a = input()
- 사용자에게 입력을 받기 전에 특정 문구를 띄우고 싶다면 다음과 같이 작성한다. input("띄우고 싶은 말")

###### print함수 자세히
- print("a" "b" "c")와 같이 큰따옴표를 사용하면 +와 연산이 같다. print("a"+"b"+"c") 와 같다. abc라고 출력된다.
- 쉼표를 사용하면 띄어쓰기가 된다. print("a", "b", "c")라고 하면 a b c 라고 출력된다.
- 파이썬에서는 print를 사용하고나면 마지막에 자동으로 줄바꿈이 된다. print("???", end='')라고 하면 줄바꿈이 되지 않는다.

#### 파일 읽고 쓰기
###### 파일 생성하기
- ??? = open("C:/(파일주소)/(파일 이름)", '?') 와 같이 생성한다. 이 때 ???에는 원하는 변수 이름을 넣고 ?에는 파일 모드를 선택한다. 파일 모드는 아래의 표에 정리하였다.

파일 열기 모드 | 설명
-- | --
'r' | 읽기 모드: 파일을 읽기만 할 때 사용한다.
'w' | 쓰기 모드: 파일에 내용을 쓸 때 사용한다.
'a' | 추가 모드: 파일의 마지막에 새로운 내용을 추가할 때 사용한다.

- 파일을 쓰기 모드로열면 해당 파일이 이미 존재할 경우에는 전부 지워지고 새로운 내용으로 덮어씌워지며 없다면 새로 생성된다.
- 파일 사용이 끝났다면 ???.close() 를 입력하여 파일을 닫아줘야한다. 쓰기 모드로 열었던 파일을 닫지 않고 다시 사용하려고 하면 오류가 발생하기 때문이다.

###### 파일 내용 쓰기
- a = open("C/(파일주소)/(파일이름)", 'w')
- data = f'할말 아무거나 {?}에는 포메팅 할 어떤 문자 넣기\n'
- a.write(data)
- a.close()
- 위와 같이 작성하면 지정한 주소에 지정한 이름을 하고있는 파일이 있으며 그 파일 내부에는 data 라는 변수를 통해 입력한 내용이 들어가 있다.

###### 파일 내용 읽기
- a = open("C/(파일주소)/(파일이름)", 'r')
- b = a.readline()
- a.close()
- 위와 같이 작성하면 b에는 지정한 주소에 지정한 이름을 하고있는 파일의 맨 첫번째 줄을 변수 b에 문자열 형태로 저장시킨다.
- b = a.readline()을 계속 반복하여 입력하면 파일에서 2번째, 3번째, ... 줄을 계속 저장시킨다. 더 이상 읽을 줄이 없을 경우 '' 와 같이 빈 문자열을 저장한다.
- 만약 b = a.readlines() 와 같이 s를 추가하여 입력하면 b에는 ["첫 번째 줄\n", "두 번째 줄\n", ...] 와 같이 리스트 형태로 저장된다.
- 여기에서 각각의 리스트에 저장된 문자열에 \n을 제거하고싶다면 for i in b: i = i.strip() 을 사용하자 (b리스트에서 제거되는게 아니므로 i 를 사용하여 새로운 식을 작성하자)
- b = a.read() 와 같이 작성하면 파일 내용 전체를 b에 문자열 형태로 저장한다.
- 위의 코드에서 맨 윗줄만 작성하여도 a에는 기본적으로 줄단위로 저장이 되어있기 때문에 for i in a: 와 같이 작성해서 줄단위로 읽을 수 있다.

###### 파일 내용 추가하기
- 파일 내용 쓰는 방법과 동일하다. 하지만 원래 저장되어있던 내용이 사라지지 않으며 뒤에 내용이 추가된다.

###### 파일 열고 닫기 자동화
- with open("C/(파일주소)/(파일이름)", '?') as a: 와 같이 작성하여 들여쓰기를 하면 들여쓰기가 끝나는 순간(with문장을 벗어나는 순간) 열린 파일 객체 a가 자동으로 닫힌다.

#### 프로그램의 입출력
###### sys 모듈 사용하기
- ??? = sys.argv[1:] 과 같이 입력했다면 프로그램 실행시 전달받은 인수를 ???에 리스트 형태로 저장한다. [1:]와 같이 첫번째를 제외하는 이유는 첫번째에는 파일 이름이 오기 때문이다.
- sys.path.append("C/(파일주소)")와 같이 입력하면 해당 파일 위치에 있는 새로운 (혹은 직접 만든) 모듈을 추가할 수 있다.


### 5장
#### 클래스
###### 클래스 생성 및 사용 예제
- 다음과 같이 작성하고 호출할 수 있다.(사칙연산)

    class FourCal:

        def __init__(self):

            self.a = 0

            self.b = 0
        
        def setdata(self, x, y):

            self.a = x

            self.b = y
        
        def add(self):

            return self.a + self.b
        
        def sub(self):

            return self.a - self.b
        
        def mul(self):

            return self.a * self.b
        
        def div(self):

            return self.a / self.b

    returnn = FourCal()

    returnn.setdata(3, 4)

    print(returnn.add())

    print(returnn.sub())

    print(returnn.mul())

    print(returnn.div())

###### 클래스 상속
- 다음과 같이 작성하면 새로운 클래스 이름으로 상속받은 클래스의 내용을 사용할 수 있다. class 새로운_클래스_이름(상속할_클래스_이름)
- 다음과 같이 작성하면 상속받은 클래스에 더하여 새로운 기능을 새로운 클래스에 추가할 수 있다.

    class More(FourCal):

        def new(self):

            ...

            return ???

    a = More()

    a.new()

- 이 기능은 기존의 클래스를 그대로 두고 기능을 추가할 때 사용한다.

###### 메서드 오버라이딩
- 상속 받기 전 클래스에 이미 def 되어있는 메서드를 상속 받은 클래스에서 똑같은 이름으로 def 하면 메서드가 덮어씌우기 된다.

###### 클래스변수
- 클래스를 정의할때 클래스 내부에서 지역변수를 하나 만들 수 있다.

class A:

    region = '?'

- 위와 같이 작성되었을때 print(A.region) 을 입력하면 ?가 출력된다.
- a = A() //// b = A() //// 라고 입력한 뒤 A.region = '!' 라고 하면 a.region 와 b.region 는 !로 저장된 값이 바뀐다.
- 다시 처음 상태에서 a.region = '!' 라고 입력하면 b.region 는 여전히 ?를 저장하고 있다. (값이 변하지 않는다.)

#### 모듈
- 모듈이란 쉽게 말해 c언어에서 헤더파일 같은 느낌이라고 보면 된다.
###### 모듈 불러오기
- import (모듈이름) 이렇게 불러오면 모듈이름.함수이름() 과 같은 형식으로 사용이 가능하다.
- from (모듈이름) import (함수이름) 이렇게 불러오면 모듈이름.함수이름() 이렇게 할 필요 없이 함수이름() 만 적어서 사용이 가능하다.
- 모듈 안에 있는 모든 함수들을 함수이름() 만 작성하여 사용하고싶다면 from (모듈이름) import * 과 같이 적으면 된다. *은 '모든 것' 을 의미한다.

###### __name__ 과 __main__의 의미
- 앞에서 불러온 모듈 내부에 def된 함수 외에 print()나 if()처럼 일반적인 함수로 이루어진 다른 작업들이 있을 때 import를 하면서 해당 작업들이 그냥 진행될 수 있다.
- 그래서 if __name__ == '__main__' 과 같이 if문을 이용하여 해당 작업들을 제한할 수 있다.
- __name__은 해당 문구가 작성된 파일.py의 이름이고 __main__은 지금 실행중인 프로그램의 파일.py의 이름이다.
- 즉 __name__에는 항상 import된 파일의 이름이 저장되어있고 __main__에는 항상 실행중인 프로그램의 이름이 저장되므로 __name__이 작성된 파일을 직접 실행시키지 않으면 위의 if문은 참이 될 수 없다.

###### 모듈에서 클래스와 변수 이용하기
- 모듈 안에 a라는 이름을 가진 변수와 b라는 이름을 가진 클래스가 있다고 하자.
- 해당 모듈의 이름을 A라고 하면 변수는 A.a 클래스는 f = A.b() 와 같이 이용한다.
- 클래스 내부에 c라는 함수가 있다면 f.c() 와 같이 이용한다.

#### 패키지
- 패키지란 관련 있는 모듈의 집합을 의미한다. 패키지는 파이썬 모듈을 계층적으로 관리할 수 있게 해준다.
- 설명에 앞서서 파일 구성을 다음과 같이 한다고 가정하자. mainfile{__init__.py , subfirst{__init__.py , fir.py}, subsec{__init__.py , sec.py}}
- fir.py 안에는 def firfir(): 이 있고 sec.py 안에는 def secsec(): 가 있다고 하자.
- 또한 처음 프로그램을 시작하는 디렉토리는 mainfile 상위폴더라고 하자.
###### 패키지 안의 함수 실행하기
- fir.py 모듈을 import하여 firfir()을 실행시키는 방법은 다음과 같다.
- import mainfile.subfirst.fir
- mainfile.subfirst.fir.firfir()

- 두 번째로 firfir() 함수를 실행시키되 from...import 하는 방법이다.
- from mainfile.subfirst import fir
- fir.firfir()

- 세 번째로 firfir() 함수를 직접 import 하는 방법이다.
- from mainfile.subfirst.fir import firfir
- firfir()

- 하지만 다음과 같이 사용하는 것은 불가능하다.
- import mainfile
- mainfile.subfirst.fir.firfir()
- 위와 같이 import를 하면 mainfile 내부의 __init__.py에서 정의한 것만 참조할 수 있다.

###### __init__.py 의 용도
- 