### 5장
#### 클래스
###### 클래스 생성 및 사용 예제
- 다음과 같이 작성하고 호출할 수 있다.(사칙연산)

    class FourCal:

        def __init__(self):

            self.a = 0

            self.b = 0
        
        def setdata(self, x, y):

            self.a = x

            self.b = y
        
        def add(self):

            return self.a + self.b
        
        def sub(self):

            return self.a - self.b
        
        def mul(self):

            return self.a * self.b
        
        def div(self):

            return self.a / self.b

    returnn = FourCal()

    returnn.setdata(3, 4)

    print(returnn.add())

    print(returnn.sub())

    print(returnn.mul())

    print(returnn.div())

###### 클래스 상속
- 다음과 같이 작성하면 새로운 클래스 이름으로 상속받은 클래스의 내용을 사용할 수 있다. class 새로운_클래스_이름(상속할_클래스_이름)
- 다음과 같이 작성하면 상속받은 클래스에 더하여 새로운 기능을 새로운 클래스에 추가할 수 있다.

    class More(FourCal):

        def new(self):

            ...

            return ???

    a = More()

    a.new()

- 이 기능은 기존의 클래스를 그대로 두고 기능을 추가할 때 사용한다.

###### 메서드 오버라이딩
- 상속 받기 전 클래스에 이미 def 되어있는 메서드를 상속 받은 클래스에서 똑같은 이름으로 def 하면 메서드가 덮어씌우기 된다.

###### 클래스변수
- 클래스를 정의할때 클래스 내부에서 지역변수를 하나 만들 수 있다.

class A:

    region = '?'

- 위와 같이 작성되었을때 print(A.region) 을 입력하면 ?가 출력된다.
- a = A() //// b = A() //// 라고 입력한 뒤 A.region = '!' 라고 하면 a.region 와 b.region 는 !로 저장된 값이 바뀐다.
- 다시 처음 상태에서 a.region = '!' 라고 입력하면 b.region 는 여전히 ?를 저장하고 있다. (값이 변하지 않는다.)

#### 모듈
- 모듈이란 쉽게 말해 c언어에서 헤더파일 같은 느낌이라고 보면 된다.
###### 모듈 불러오기
- import (모듈이름) 이렇게 불러오면 모듈이름.함수이름() 과 같은 형식으로 사용이 가능하다.
- from (모듈이름) import (함수이름) 이렇게 불러오면 모듈이름.함수이름() 이렇게 할 필요 없이 함수이름() 만 적어서 사용이 가능하다.
- 모듈 안에 있는 모든 함수들을 함수이름() 만 작성하여 사용하고싶다면 from (모듈이름) import * 과 같이 적으면 된다. *은 '모든 것' 을 의미한다.

###### \_\_name__ 과 __main__의 의미
- 앞에서 불러온 모듈 내부에 def된 함수 외에 print()나 if()처럼 일반적인 함수로 이루어진 다른 작업들이 있을 때 import를 하면서 해당 작업들이 그냥 진행될 수 있다.
- 그래서 if \_\_name__ == '\_\_main__' 과 같이 if문을 이용하여 해당 작업들을 제한할 수 있다.
- __name__은 해당 문구가 작성된 파일.py의 이름이고 __main__은 지금 실행중인 프로그램의 파일.py의 이름이다.
- 즉 __name__에는 항상 import된 파일의 이름이 저장되어있고 __main__에는 항상 실행중인 프로그램의 이름이 저장되므로 __name__이 작성된 파일을 직접 실행시키지 않으면 위의 if문은 참이 될 수 없다.

###### 모듈에서 클래스와 변수 이용하기
- 모듈 안에 a라는 이름을 가진 변수와 b라는 이름을 가진 클래스가 있다고 하자.
- 해당 모듈의 이름을 A라고 하면 변수는 A.a 클래스는 f = A.b() 와 같이 이용한다.
- 클래스 내부에 c라는 함수가 있다면 f.c() 와 같이 이용한다.

#### 패키지
- 패키지란 관련 있는 모듈의 집합을 의미한다. 패키지는 파이썬 모듈을 계층적으로 관리할 수 있게 해준다.
- 설명에 앞서서 파일 구성을 다음과 같이 한다고 가정하자. mainfile{\_\_init__.py , subfirst{\_\_init__.py , fir.py}, subsec{\_\_init__.py , sec.py}}
- fir.py 안에는 def firfir(): 이 있고 sec.py 안에는 def secsec(): 가 있다고 하자.
- 또한 처음 프로그램을 시작하는 디렉토리는 mainfile 상위폴더라고 하자.
###### 패키지 안의 함수 실행하기
- fir.py 모듈을 import하여 firfir()을 실행시키는 방법은 다음과 같다.

import mainfile.subfirst.fir

mainfile.subfirst.fir.firfir()


- 두 번째로 firfir() 함수를 실행시키되 from...import 하는 방법이다.

from mainfile.subfirst import fir

fir.firfir()


- 세 번째로 firfir() 함수를 직접 import 하는 방법이다.

from mainfile.subfirst.fir import firfir

firfir()


- 하지만 다음과 같이 사용하는 것은 불가능하다.

import mainfile

mainfile.subfirst.fir.firfir()

- 위와 같이 import를 하면 mainfile 내부의 \_\_init__.py에서 정의한 것만 참조할 수 있다.

###### \_\_init__.py 의 용도
- mainfile 내부의 \_\_init__.py 안에 변수 A = 1 과 def maintest(): 가 있다고 하자
- 이와 같이 작성하면 import mainfile 만 작성하여도 \_\_init__.py 에서 정의한 변수와 함수는 사용이 가능하다.
- 또한 패키지 내부의 다른 모듈을 미리 import 하여 패키지를 사용하는 코드에서 간편하게 접근이 가능해진다.

from .subsec.sec import secsec

- 다음과 같이 mainfile 내부의 \_\_init__.py 내부에 작성이 되어있다면

import mainfile

mainfile.secsec()

- 이와 같이 작성이 가능해진다.
- 그리고 \_\_init__.py에는 패키지를 처음 불러울 때 실행되어야 하는 코드를 작성할 수 있다.
- 처음 불러올 때 실행되는 코드는 예를 들어 mainfile의 init에 작성되어 있다고 하면 subfirst나 subsec와 같이 하위 모듈을 불러올때도 실행된다.
- 하지만 subfirst를 불러옴으로 mainfile의 init에 있는 첫실행 코드를 불러왔다면 subsec를 불러와도 다시 실행되지 않는다.
- 다음과 같이 코드를 작성하면

from mainfile.subsec import *

- subsec 내부의 \_\_init__.py 에서 \_\_all__ = ['sec', '파일이름', '파일이름2', ...] 리스트 내부에 적혀져 있는 파일만 import 된다.

###### relative 패키지
- sec.py 내부에서 fir.py를 import 하려고 할 때 다음의 두 줄의 문구는 같은 역할을 한다.

from mainfile.subfirst.fir import firfir()

from ..subfirst.fir import firfir()

- 여기에서 ..은 sec.py 파일의 부모 디렉터리를 의미한다. (점 하나는 현재 디렉터리를 의미한다.) fir.py 의 부모 디렉토리와 sec.py 부모 디렉터리가 같으므로 사용이 가능하다.
- fir.py의 현재 디렉터리는 subfirst이며 부모 디렉터리는 mainfile이 된다.

#### 예외 처리
- 프로그램에서 오류가 발생하였을때 프로그램을 정지시키지 않고 진행하기 위해 사용한다.
###### 오류 예외 처리 기법
- try - except 구문이 있는데 작성 형태에 따라 어떻게 사용되는지 정리했다.
- 첫 번째로 try - except 만 사용하는 방법이다.

try:

(무언가 실행할 코드들..., 오류가 나면 except에 있는 ... 문구를 실행한다.)

except:

...

- 이 경우에는 오류에 종류에 상관없이 오류가 나면 except로 넘어간다.
- 두 번째로 특정 오류가 났을때만 넘어가는 방법이다.

try:

...

except (발생오류):

...

- 이 경우는 오류가 발생하였을 때 except 뒤에 적어둔 오류와 동일한 오류만 except에 있는 문구를 실행한다.
- 세 번째로 발생 오류와 변수를 포함한 방법이다.

try:

...

except (발생오류) as (오류변수):

...

- 이 경우는 오류변수에 오류메시지가 저장된다. print()를 이용하면 오류메시지를 띄울 수 있다.
- except 절에 문구를 작성할 때 pass를 입력하면 그냥 오류를 회피하고 (try에서 하던 작업은 중지하고)넘어간다.

###### try-finally 문

try:

(무언가 실행할 코드들...)

finally:

(중간에 오류가 발생해도 무조건 실행할 코드)

- finally문구는 try 안에 있는 코드에서의 오류 발생 여부와 상관 없이 항상 수행된다.

###### 여러 개의 오류 처리하기
- if 문에서 elif를 여러번 쓰듯이 try문에서도 except문을 여러번 사용이 가능하다.
- 여러번 쓰는 except문에서도 elif와 같이 (발생오류) as (오류변수) 를 각각 사용하는 것이 가능하다.
- 발생 오류에는 ZeroDivisionError, IndexError, FileNotFoundError 등이 있다.
- (발생오류) 칸에는 (오류1, 오류2, ...) 처럼 여러 오류를 함께 처리할 수 있다.

###### try-else 문

try:

...

except:

...

else:

...

- 다음과 같이 작성하여 try 안에서 오류가 발생하면 except, 발생하지 않으면 else 내부에 있는 코드를 실행한다.

###### 오류 발생시키기
- raise를 사용하면 오류를 발생시킬 수 있다. ex) raise NotImplementedError

###### 파이썬 내장 클래스로 예외 만들기
- Exception 이라는 내장 클래스가 있다. 이를 이용하여 클래스를 만드려면 클래스 상속을 이용하자. ex) class MyError(Exception):
- 위의 예시에서 클래스 상속을 한 뒤에 def \_\_str__(self): 를 작성한 뒤 return "할말" 을 작성하면 except (클래스 이름 (발생오류)) as (오류변수) 에서 오류변수에 "할말"이 저장된다.

#### 내장 함수
- 파이썬 안에 자체적으로 있는 함수들이다 print, if, while 등이 그것이다.

함수 | 설명
-- | --
abs(x) | - x로 어떤 숫자를 입력받았을 때 그 숫자의 절댓값을 리턴한다.
all(x) | - x로 반복 가능 데이터(리스트, 튜플, 문자열, 딕셔너리, 집합 등등...)를 받아서 x의 요소들이 전부 참이면 True 하나라도 거짓이면 False를 리턴한다. </br> - 요소가 아무것도 없으면 True를 리턴한다.
any(x) | - x로 반복 가능한 데이터를 받아서 x의 요소들이 전부 거짓이면 False 하나라도 참이면 True를 리턴한다. </br> - 요소가 아무것도 없으면 False를 리턴한다.
chr(x) | - x로 유니코드 숫자 값을 입력받아 그 코드에 해당하는 문자를 리턴한다.
ord(x) | - x에 문자 하나를 입력하면 그 문자의 유니코드 숫자 값을 리턴한다.
dir(x) | - x로 객체를 받아 그 객체가 지닌 변수나 함수를 보여준다. (리스트를 입력하면 리스트 관련 함수인 append, count, extend 등등...)
divmod(x, y) | - x를 y로 나눈 몫과 나머지를 튜플 형태로 리턴한다.
enumerate(x) | - x로 순서가있는 데이터(리스트, 튜플, 문자열)를 입력받아 인덱스 값을 포함하는 객체를 리턴한다. </br> - for i, name in enumerate(['a', 'b', 'c']): 이렇게 하면 i와 name에는 (0, a), (1, b), (2, c) 가 순서대로 입력되어 반복된다.
eval(x) | - x로 문자열로 구성된 표현식을 입력받아 해당 문자열을 실행한 결괏값을 리턴하는 함수이다. </br> - 하지만 이 함수를 사용하면 보안에 취약하다.(저 함수 입력값으로 악성코드를 다운받는 웹사이트 접속 명령어를 입력할수도 있다.)
filter(x, y) | - x에는 출력값이 불 대수인 함수, y에는 반복 가능한 데이터를 받는다. x함수에 y값을 차례대로 넣어 리턴값이 참인 것만 출력한다. (리스트를 씌우면 간단하게 볼 수 있다. 리스트를 씌우지 않으면 print로 볼 수 없다.)
hex(x) | - x로 정수를 입력받아 16진수 문자열로 리턴한다.
oct(x) | - x로 정수를 입력받아 8진수 문자열로 리턴한다.
id(x) | - x로 객체를 입력받아 객체의 고유 주솟값을 리턴한다.
int(x, y) | - (y입력값이 없을 때) x로 입력된 문자열, float형태의 수를 정수로 리턴한다. </br> x가 문자열로 표현된 수 일때 y에서 x에 표현한 수가 몇진수인지 입력하면 10진수 정수형으로 리턴한다.
isinstance(x, y) | - x에는 변수를 y에는 class 이름을 넣으면 x가 y클래스의 인스턴스일때는 True를 아닐때는 False를 리턴한다.
map(x, y) | - x에는 함수를 y에는 반복 가능한 데이터를 입력받아서 반복 가능한 데이터를 순서대로 x의 함수에 대입하여 결과를 리턴한다. (이것 역시 리스트를 씌우지 않으면 print로 볼 수 없다.)
max(x) | - x에 반복 가능한 데이터를 입력받아 최댓값을 리턴한다.
min(x) | - x에 반복 가능한 데이터를 입력받아 최솟값을 리턴한다.
pow(x, y) | - x를 y제곱한 결과를 리턴한다. (x^y)
round(x, y) | - x를 반올림하여 리턴한다. </br> - y를 입력하지 않으면 소수점 첫 번째 자리에서 반올림하며 y에는 표시하고 싶은 소수점의 자릿수를 입력한다.
sorted(x) | - x에 입력 데이터를 정렬하여 그 결과를 리스트로 리턴한다. </br> - listA.sort() 는 리스트 그 자체를 정렬하고 리턴하지 않는다는 차이가 있다.
sum(x) | - x에 입력된 데이터의 합을 리턴한다.
zip(*x) | - x에는 반복 가능한 데이터를 여러 개 입력이 가능하다. </br> - x에는 리스트, 튜플, 문자열 등이 들어가며 마치 행렬에서 ^T와 같은 일을 수행한다.

#### 표준 라이브러리
- 파이썬 프로그래밍 능력을 높여주는 유용한 프로그램을 모아 놓은 것이다.
- 모든 라이브러리를 다 알 필요는 없고 어떤 일을 할 때 어떤 라이브러리를 사용해야 하는지 정도만 알면 된다. (책에 적혀있는 바에 따르면...?)
- 따라서 어떤 라이브러리가 어떤 역할을 하는지 정도만 간단하게 요약해놓는다.

라이브러리(import 뒤에 넣어야함) | 설명
-- | --
datetime | - 연, 월, 일 날짜를 표현할 때 사용한다. </br> - 함수로는 객체를 생성할때 쓰는 .date(?, ?, ?) 요일을 월화수목 순서대로 0,1,2,3으로 반환하는 .weekdat() 등이 있다.
time | - 시간과 관련된 함수들이 매우 많다. </br> - 함수로는 .time, .localtime, .asctime, .ctime, .strftime, .sleep 등이 있다.
math | - 말 그대로 계산을 편하게 해준다. </br> - .gcd 는 최대 공약수를 쉽게 구할 수 있다. </br> - .lcm 은 최소 공배수를 쉽게 구할 수 있다.
random | - 난수를 발생시키는 모듈이다. </br> - .random() 은 0부터 1사이의 실수 중에서 난수를 리턴한다. </br> - .randint(?, ?)는 두 정수 사이의 정수 난수 값을 리턴한다.
itertools | - .zip_longest(?, ?, ?) 는 위의 zip(*x) 함수와 동작이 비슷하다. 길이가 다르면 짧은 객체의 길이에 맞춘다. 만약 마지막? 자리에 fillvalue='!' 값을 정하면 부족한 값은 !값에 맞춰서 긴 길이의 객체에 맞춘다. </br> - .permutations(?, !)은 반복 가능 객체 중에서 !개를 선택한 순열을 이터레이터로 리턴한느 함수이다. 쉽게 말하자면 ?에 있는 반복 가능 객체 중에서 !개를 뽑아 만들 수 있는 모든 경우의 수를 전부 출력한다. </br> - .combination(?, !) 는 고등학교 수학에서 컴비네이션을 생각하면 된다. 모든 경우를 출력한다. (?에는 반복 가능 객체)
functools | - .reduce(?, !) 는 ?에 함수를 !에 반복 가능한 객체를 넣는다. 반복 가능한 객체의 요소를 순서대로 함수에 누적 적용하여 하나의 값으로 줄이는 함수이다. (즉 함수의 입력값은 2개가 되어야 한다.)
operator | - .itemgetter 는 튜플로 이루어진 리스트를 튜플 내부의 특정 순서에 있는 요소를 기준으로 정렬할 때 사용한다. </br> - .attrgetter 는 리스트가 아닌 클래스일때 itemgetter와 유사하게 정렬을 해준다.
shutil | - .copy("(파일주소)/(파일이름)", "(파일주소)/(파일이름)") 은 파일을 복사할 때 이용한다. </br> - .move("(파일주소)/(파일이름)", "(파일주소)/(파일이름)") 역시 파일을 이동할 때 이용한다.
glob | - .glob("(파일주소)/(파일이름일부*)") 해당 파일 주소에 파일이름 일부가 들어간 모든 파일을 읽어서 리스트 형태로 리턴한다. * 대신 ?를 넣으면 ?하나당 1자리 문자열을 의미한다.
pickle | - pickle은 변수의 형태를 그대로 유지하면서 파일에 저장하고 불러올 수 있게 하는 모듈이다. .dump, .load를 사용하면 저장하고 불러올 수 있다.
os | - .chdir("(파일위치)") 를 이용하여 현제 디렉터리의 위치를 변경할 수 있다. </br> - .getcwd()를 이용하여 자신의 디렉터리 위치를 리턴한다. </br> - 그밖에도 디렉터리 생성, 디렉터리 삭제, 파일 삭제, 이름 변경 등 많은 작업을 할 수 있다.
zipfile | - 이름에서 알 수 있듯이 여러 파일을 zip형식으로 합치거나 해제할 때 사용한다.
tempfile | - .mkstemp()파일을 임시로 만들어서 사용할 수 있다. </br> - .TemporaryFile()은 임시 저장 공간으로 사용할 파일 객체를 리턴한다.
traceback | - .format_exc()는 오류 추적 결과를 문자열로 리턴하는 함수이다.
json | - json데이터를 쉽게 처리하고자 사용하는 모듈이다. (최근에 뜯어본 펠월드와 좀보이드 같은 게임들도 json방식을 사용했었다.) </br> - .load(?) 를 이용해 ?에는 open()으로 파일을 받은 변수를 넣으면 읽을 수 있다. </br> - .dump(!, ?)를 이용해 반대로 파일?에 딕셔너리!를 저장할 수 있다.
urllib | - URL을 읽고 분석할 때 사용한다. </br> - urllib.request.urlopen로 객체를 생성하고 .read()로 리소스 내용 전체를 읽어 이를 저장할 수 있다.
webbrowser | - .open_new("(사이트주소)")를 사용하면 새 창으로 주소가 열리고 .open("(사이트주소)")를 사용하면 이미 열린 브라우저에서 사이트가 열린다.

#### 외부 라이브러리
- 외부 라이브러리는 표준 라이브러리와 달리 다운로드되어있지 않아서 pip도구를 이용해 설치해야한다.
###### pip
- pip install (패키지 이름) 이렇게 하면 원하는 패키지를 다운받을 수 있다.
- pip uninstall (패키지 이름) 이렇게 하면 특정 패키지를 삭제할 수 있다.
- pip install (패키지 이름)==(버전) 이렇게 하면 특정 버전의 패키지를 설치할 수 있다.
- pip install --upgrade (패키지 이름) 최신 버전으로 업그레이드 한다.
- pip list 설치된 패키지 목록을 볼 수 있다.

###### Faker 모듈
- 테스트용 가짜 데이터를 생성할 때 사용하는 라이브러리이다.
- .name(), .address(), .postcode() 등등 이름이나 주소, 번호 등 많은 것을 만들 수 있다.

###### sympy 모듈
- 방정식 기호를 사용하게 해 주는 외부 라이브러리이다.
- x = sympy.symbols("x") 이와 같이 x를 미지수를 나타내는 기호로 만들 수 있다.
- x, y = sympy.symbols('x, y') 와 같이 2개 이상을 기호로 만들 수 있다.
- f = sympy.Eq((x를 사용한 식 우변항), (좌변항)) 이와 같이 식을 세운 뒤 sympy.solve(f) 를 사용하면 x에 해당하는 값을 구할 수 있다.
- 방정식이 2개 이상일 때에는 sympy.solve([(위의 f와 같은 식1), (식2)]) 로 할 수 있다. 미지수가 2개 이상이면 딕셔너리로 리턴한다.


### 6장
- (실습 위주라서 요약할 내용이 없습니다.)